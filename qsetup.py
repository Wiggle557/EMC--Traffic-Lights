# qsetup.py
import simpy
import random
import numpy as np
from quiet import FCar, FRoad
from scipy.stats import truncnorm

def Fsetup(env: simpy.Environment, num_cars: int, roads: list[FRoad], base_mean: float | int):
    """
    Sets up the simulation by launching a process that creates cars.
    Arrival intervals are generated by a Poisson distribution; during rush hour,
    intervals are reduced to simulate higher traffic volumes.
    """
    for i in range(num_cars):
        # Select roads where the junction_start is marked as an entry point.
        startable = [
            road for road in roads
            if hasattr(road.junction_start, "start") and road.junction_start.start
            and not road.junction_end.end  # Exclude roads that lead directly to an exit.
        ]

        if not startable_roads:
            break
        # Choose based on inverted queue length for load balancing.
        weights = [1 / (len(road.car_queue.items) + 1) for road in startable_roads]
        chosen_road = random.choices(startable_roads, weights=weights)[0]
        
        # Create a car with a reaction time sampled from the distribution.
        reaction_time = sample_reaction_time(mean=1.0, std=0.2)
        car = FCar(env, f"Car {i}", chosen_road, roads, reaction_time=reaction_time)
        env.process(car.run())
        
        current_time = env.now
        # Adjust arrival rate during rush hours (for example, between 270 and 360 seconds).
        if 270 <= current_time < 360:
            current_mean = base_mean * 0.5
        else:
            current_mean = base_mean
        interval = sample_arrival_interval(current_mean)
        yield env.timeout(interval)

def Fcreate_grid_roads(junctions: list[list[int]]) -> list[list[int | str]]:
    """
    Given a 2D grid of junction indices, this utility creates a list of road connections.
    Each connection is specified as a list: [start_index, end_index, initial_colour].
    """
    road_names = []
    for i, row in enumerate(junctions):
        for j, cell in enumerate(row):
            if i > 0:
                road_names.append([cell, cell - len(row), "RED"])
            if i < len(junctions) - 1:
                road_names.append([cell, cell + len(row), "RED"])
            if j > 0:
                road_names.append([cell, cell - 1, "GREEN"])
            if j < len(row) - 1:
                road_names.append([cell, cell + 1, "GREEN"])
    return road_names

def sample_reaction_time(mean=1.0, std=0.2, lower=0.5, upper=1.5) -> float:
    """
    Samples a driver reaction time from a truncated normal distribution.
    """
    a, b = (lower - mean) / std, (upper - mean) / std
    return truncnorm.rvs(a, b, loc=mean, scale=std)

def sample_arrival_interval(base_mean):
    """
    Samples an arrival interval from a Poisson distribution and
    ensures that the interval is at least 1 second.
    """
    interval = np.random.poisson(lam=base_mean, size=1)[0]
    return max(1, interval)
